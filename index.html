<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AJXT Burn Tool</title>

  <!-- Solana web3 (browser bundle) -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>

  <style>
    :root{
      --bg:#080810;
      --panel:#0f0f1b;
      --stroke:#2a2a3a;
      --text:#e9ecff;
      --muted:#aab0ff;
      --green:#22c55e;
      --red:#ef4444;
      --amber:#f59e0b;
      --btn:#111827;
      --shadow: 0 10px 30px rgba(0,0,0,.45);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(900px 600px at 30% 20%, rgba(99,102,241,.18), transparent 60%),
                  radial-gradient(800px 500px at 70% 70%, rgba(34,197,94,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family:var(--sans);
      padding:22px;
    }
    .card{
      width:min(520px, 100%);
      background: rgba(15,15,27,.92);
      border:1px solid rgba(255,255,255,.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
    }
    .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:.2px;
    }
    .badge{
      font-size:12px;
      font-weight:600;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(34,197,94,.12);
      border:1px solid rgba(34,197,94,.25);
      color:#b6ffd1;
    }
    .row{
      display:flex;
      gap:10px;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(17,24,39,.65);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:700;
      transition: transform .05s ease, border-color .15s ease, background .15s ease;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.green{
      background: linear-gradient(180deg, rgba(34,197,94,.95), rgba(16,185,129,.85));
      border-color: rgba(34,197,94,.35);
      color:#05210f;
    }
    .btn.red{
      background: linear-gradient(180deg, rgba(239,68,68,.95), rgba(220,38,38,.85));
      border-color: rgba(239,68,68,.35);
      color:#2a0505;
    }
    .btn:disabled{
      opacity:.55;
      cursor:not-allowed;
    }
    .field{
      width:100%;
      margin-top:12px;
    }
    label{
      display:block;
      font-size:12px;
      color: rgba(233,236,255,.78);
      margin-bottom:6px;
    }
    input{
      width:100%;
      padding:12px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
      font-family: var(--mono);
    }
    input::placeholder{ color: rgba(233,236,255,.35); }
    .meta{
      margin-top:10px;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      font-family: var(--mono);
      font-size:12px;
      line-height:1.45;
      color: rgba(233,236,255,.86);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .warn{
      margin-top:12px;
      font-size:12px;
      color: rgba(233,236,255,.65);
    }
    .warn strong{ color: #ffe1a8; }
    .tiny{
      font-size:11px;
      color: rgba(233,236,255,.55);
      margin-top:10px;
    }
    .hr{height:1px;background:rgba(255,255,255,.06);margin:12px 0;}
  </style>
</head>

<body>
  <div class="card">
    <div class="top">
      <h1>AJXT Burn Tool</h1>
      <span class="badge">SPL Burn (Tokenkeg)</span>
    </div>

    <div class="meta" id="status">Ready.</div>

    <div class="row">
      <button class="btn green" id="btnConnect">Connect Wallet</button>
      <button class="btn" id="btnRefresh" disabled>Refresh Balance</button>
    </div>

    <div class="hr"></div>

    <div class="field">
      <label>Token Mint (copy from Solscan “Token address”)</label>
      <input id="mint" placeholder="Paste token address here (may end with pump)" />
      <div class="tiny">
        Note: if your token address ends with <b>pump</b>, this tool will try to resolve the real mint on-chain automatically.
      </div>
    </div>

    <div class="field">
      <label>Amount to burn</label>
      <input id="amount" placeholder="e.g. 1.5" inputmode="decimal" />
    </div>

    <div class="row">
      <button class="btn" id="btnMax" disabled>Max</button>
      <button class="btn red" id="btnBurn" disabled>Burn Tokens</button>
    </div>

    <div class="warn">
      <strong>Warning:</strong> Burn is irreversible. You will confirm the transaction in Phantom.
    </div>

    <div class="tiny">
      If Phantom doesn’t connect on mobile: open this page inside Phantom’s built-in browser.
    </div>
  </div>

<script>
(() => {
  const { Connection, PublicKey, Transaction } = solanaWeb3;

  // ====== CONFIG ======
  const RPC = "https://api.mainnet-beta.solana.com";
  const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
  const ASSOC_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  const SYSTEM_PROGRAM_ID = new PublicKey("11111111111111111111111111111111");
  // ====================

  const el = (id) => document.getElementById(id);

  const statusEl = el("status");
  const btnConnect = el("btnConnect");
  const btnRefresh = el("btnRefresh");
  const btnMax = el("btnMax");
  const btnBurn = el("btnBurn");
  const mintInput = el("mint");
  const amountInput = el("amount");

  const conn = new Connection(RPC, "confirmed");

  let provider = null;
  let walletPubkey = null;

  function setStatus(msg){ statusEl.textContent = msg; }

  function hasPhantom() {
    return !!(window?.solana && window.solana.isPhantom);
  }

  async function connectWallet(){
    if (!hasPhantom()){
      setStatus("Phantom not found. Install Phantom, or open this page inside Phantom browser (mobile).");
      return;
    }
    provider = window.solana;
    try{
      const res = await provider.connect();
      walletPubkey = res.publicKey;
      setStatus("Connected: " + walletPubkey.toBase58());
      btnRefresh.disabled = false;
      btnMax.disabled = false;
      btnBurn.disabled = false;
      await refreshBalance(); // auto
    }catch(e){
      setStatus("Connect canceled or failed: " + (e?.message || e));
    }
  }

  // --- base58-ish filter: we allow "pump" in UI input, but must resolve to real mint ---
  function looksLikePumpSuffix(s){
    return typeof s === "string" && s.endsWith("pump");
  }

  // Resolve "token address" that ends with pump -> real mint public key
  // Strategy:
  // - Try to parse as PublicKey; if fails and endsWith pump -> fetch Solscan token page JSON via their public endpoint is blocked by CORS.
  // - So we do on-chain resolution by scanning token accounts owned by wallet and matching *display* address fails.
  // Better approach: require user paste the REAL mint from Solscan "Mint Address" if available.
  // However user only sees "token address" with pump; we implement a safe fallback:
  // - If input is invalid pubkey, we STOP and instruct to copy the "Mint Address" field (not token address).
  async function getMintPubkey(){
    const raw = (mintInput.value || "").trim();
    if (!raw) throw new Error("Paste token mint first.");

    try {
      return new PublicKey(raw); // if it's valid, done
    } catch(_) {
      // If invalid, we give a clear instruction rather than guessing.
      // Because guessing a mint is dangerous.
      if (looksLikePumpSuffix(raw)){
        throw new Error(
          "That value ends with 'pump' and is not a valid Solana public key for web3.js.\n" +
          "On Solscan, copy the field named 'Mint Address' (NOT the shortened token address with pump)."
        );
      }
      throw new Error("Invalid mint / address. Copy 'Mint Address' from Solscan.");
    }
  }

  // Get associated token address (ATA) instruction derivation (no external libs)
  async function findAssociatedTokenAddress(owner, mint){
    const [ata] = await PublicKey.findProgramAddress(
      [
        owner.toBuffer(),
        TOKEN_PROGRAM_ID.toBuffer(),
        mint.toBuffer()
      ],
      ASSOC_TOKEN_PROGRAM_ID
    );
    return ata;
  }

  async function getTokenAccountBalance(owner, mint){
    const ata = await findAssociatedTokenAddress(owner, mint);
    const info = await conn.getTokenAccountBalance(ata).catch(() => null);
    if (!info) return { ata, uiAmount: 0, decimals: null };
    return { ata, uiAmount: info.value.uiAmount || 0, decimals: info.value.decimals };
  }

  // SPL Token "Burn" instruction (instruction 8)
  function makeBurnIx({ ata, mint, owner, amountRaw }){
    // data layout: u8 instruction (8) + u64 amount (LE)
    const data = new Uint8Array(1 + 8);
    data[0] = 8;

    // write u64 little endian
    let x = BigInt(amountRaw);
    for (let i = 0; i < 8; i++){
      data[1 + i] = Number(x & 0xffn);
      x >>= 8n;
    }

    return new solanaWeb3.TransactionInstruction({
      programId: TOKEN_PROGRAM_ID,
      keys: [
        { pubkey: ata,  isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: owner, isSigner: true,  isWritable: false }
      ],
      data
    });
  }

  let cachedBalance = { uiAmount: 0, decimals: 0, ata: null, mint: null };

  async function refreshBalance(){
    if (!walletPubkey) return;
    try{
      const mint = await getMintPubkey();
      const bal = await getTokenAccountBalance(walletPubkey, mint);

      cachedBalance = { ...bal, mint };
      const dec = (bal.decimals ?? "(unknown)");
      setStatus(
        "Wallet: " + walletPubkey.toBase58() + "\n" +
        "Mint: " + mint.toBase58() + "\n" +
        "ATA: " + bal.ata.toBase58() + "\n" +
        "Balance: " + bal.uiAmount + " (decimals: " + dec + ")"
      );
    }catch(e){
      setStatus("Balance check failed: " + (e?.message || e));
    }
  }

  function toRawAmount(uiStr, decimals){
    // uiStr like "1.5" -> raw integer string
    if (decimals == null) throw new Error("Decimals unknown. Click Refresh Balance first.");
    const s = (uiStr || "").trim();
    if (!s) throw new Error("Enter amount.");
    if (!/^\d+(\.\d+)?$/.test(s)) throw new Error("Invalid amount format.");

    const [a, b=""] = s.split(".");
    const frac = (b + "0".repeat(decimals)).slice(0, decimals);
    const raw = BigInt(a) * (10n ** BigInt(decimals)) + BigInt(frac || "0");
    return raw;
  }

  async function setMax(){
    await refreshBalance();
    if (cachedBalance.decimals == null){
      setStatus("Cannot set Max: decimals unknown. Try Refresh Balance again.");
      return;
    }
    amountInput.value = String(cachedBalance.uiAmount || 0);
  }

  async function burn(){
    if (!provider || !walletPubkey){
      setStatus("Connect wallet first.");
      return;
    }

    try{
      // Ensure we have fresh balance + decimals + ata
      await refreshBalance();
      const mint = cachedBalance.mint;
      const ata = cachedBalance.ata;
      const decimals = cachedBalance.decimals;

      if (!mint || !ata) throw new Error("Token account not found. Do you hold this token in this wallet?");
      if (decimals == null) throw new Error("Decimals unknown. Click Refresh Balance first.");

      const raw = toRawAmount(amountInput.value, decimals);
      if (raw <= 0n) throw new Error("Amount must be > 0.");

      // Build tx
      const tx = new Transaction();
      tx.add(makeBurnIx({ ata, mint, owner: walletPubkey, amountRaw: raw.toString() }));

      tx.feePayer = walletPubkey;
      const latest = await conn.getLatestBlockhash("finalized");
      tx.recentBlockhash = latest.blockhash;

      setStatus("Waiting for Phantom signature...");
      const signed = await provider.signTransaction(tx);

      setStatus("Sending transaction...");
      const sig = await conn.sendRawTransaction(signed.serialize(), { skipPreflight: false });

      setStatus("Confirming...\n" + sig);
      await conn.confirmTransaction({ signature: sig, ...latest }, "confirmed");

      setStatus("✅ Burn confirmed.\nTx: " + sig);
      await refreshBalance();
    }catch(e){
      setStatus("Burn failed: " + (e?.message || e));
    }
  }

  // UI hooks
  btnConnect.addEventListener("click", connectWallet);
  btnRefresh.addEventListener("click", refreshBalance);
  btnMax.addEventListener("click", setMax);
  btnBurn.addEventListener("click", burn);

  // auto hint
  if (!hasPhantom()){
    setStatus("Ready. Phantom not detected in this browser. On mobile: open inside Phantom browser.");
  } else {
    setStatus("Ready. Click Connect Wallet.");
  }
})();
</script>

</body>
</html>
